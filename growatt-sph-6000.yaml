########################################################################################
#                                                                                      #
#      Growatt SPH Inverter Modbus yaml configuration for ESPHome                      #
#      Thanks to Christian Ravn Christiansen                                           #
#                                                                                      #
#      - Use write functions at your own risk                                          #
#                                                                                      #
#      - Comment out unused sensors or numbers                                         #
#        (ex the Grid Timers) for better performance from the ESP                      #
#                                                                                      #
#       THE FILE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.                    #
#       IN NO EVENT SHALL THE AUTHOR OR COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM,      #
#       DAMAGES OR OTHER LIABILITY                                                     #
#                                                                                      #
########################################################################################


#######################
# Configuration begin #
#######################

substitutions:
  device_description: Growatt Inverter
  friendly_name:  Growatt Inverter
  name: "growatt-sph-6000"
  update_interval_set: "30s" # 60s recommended

esphome:
  name: ${name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: DEBUG #VERY_VERBOSE
  baud_rate: 9600
  #baud_rate: 0

# Disable Home Assistant API
#api:

# Enable MQTT Client which we need to talk to Predbat
mqtt:
  id: mqtt_client
  broker: 192.168.4.100
  port: 1883
  username: !secret mqtt_user
  password: !secret mqtt_password
  discovery: true
  birth_message: 
    topic: growatt/status
    payload: online
  will_message:
    topic: growatt/status
    payload: offline

ota:
  - platform: esphome

wifi:
  networks:
  - ssid: Static@5aC
    password: gct466&5&XCY
  ap: {}

captive_portal:

web_server:
  port: 80
  local: true

uart:
  id: uart_modbus
  baud_rate: 9600
  data_bits: 8
  stop_bits: 1
  parity: NONE
  rx_pin: GPIO1
  tx_pin: GPIO3
  #cts_pin: GPIO18 #required if using MAX485
  #rts_pin: GPIO19

####################
# Configuration end#
####################

modbus:
  id: modbus_id
  uart_id: uart_modbus

modbus_controller:
  id: growatt_modbus_controller
  address: 0x1
  modbus_id: modbus_id
  update_interval: ${update_interval_set}

##############################
# Holding Register Switches  #
##############################

switch:
    # Switch Holding registers - ordered by register id
    - platform: modbus_controller
      name: "Inverter Export Limit Enabled"
      register_type: holding
      address: 0x0122
      use_write_multiple: true
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 1 Enabled"
      register_type: holding
      address: 0x1082
      use_write_multiple: true
      bitmask: 1
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 2 Enabled"
      register_type: holding
      address: 0x1085
      use_write_multiple: true
      bitmask: 1
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 3 Enabled"
      register_type: holding
      address: 0x1088
      use_write_multiple: true
      bitmask: 1
    - platform: modbus_controller
      name: "Battery BatteryFirst AC Charge Enabled"
      register_type: holding
      address: 0x1092
      use_write_multiple: true
      bitmask: 1
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 1 Enabled"
      register_type: holding
      address: 0x1102
      use_write_multiple: true
      bitmask: 1
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 2 Enabled"
      register_type: holding
      address: 0x1105
      use_write_multiple: true
      bitmask: 1
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 3 Enabled"
      register_type: holding
      address: 0x1108
      use_write_multiple: true
      bitmask: 1
      #
      # Experimental registers for test
      #
    # - platform: modbus_controller
    #   name: "Inverter - EESysInfo - bDischargeEn"
    #   register_type: holding
    #   address: 1008
    #   use_write_multiple: true
    #   bitmask: 32
    # - platform: modbus_controller
    #   name: "Inverter - EESysInfo - ForceDischrEn"
    #   register_type: holding
    #   address: 1008
    #   use_write_multiple: true
    #   bitmask: 64
    # - platform: modbus_controller
    #   name: "Inverter - EESysInfo - ChargeEn"
    #   register_type: holding
    #   address: 1008
    #   use_write_multiple: true
    #   bitmask: 128
    # - platform: modbus_controller
    #   name: "Inverter - EESysInfo - bForceChrEn"
    #   register_type: holding
    #   address: 1008
    #   use_write_multiple: true
    #   bitmask: 256
    # - platform: modbus_controller
    #   name: "Inverter - EESysInfo - bBackUpEn"
    #   register_type: holding
    #   address: 1008
    #   use_write_multiple: true
    #   bitmask: 512
    # - platform: modbus_controller
    #   name: "Inverter - EESysInfo - bInvLimitLoadE"
    #   register_type: holding
    #   address: 1008
    #   use_write_multiple: true
    #   bitmask: 1024
    # - platform: modbus_controller
    #   name: "Inverter - EESysInfo - bSpLimitLoadEn"
    #   register_type: holding
    #   address: 1008
    #   use_write_multiple: true
    #   bitmask: 2048
    # - platform: modbus_controller
    #   name: "Inverter - EESysInfo - bACChargeEn"
    #   register_type: holding
    #   address: 1008
    #   use_write_multiple: true
    #   bitmask: 4096
    # - platform: modbus_controller
    #   name: "Inverter - EESysInfo - bPVLoadLimitEn"
    #   register_type: holding
    #   address: 1008
    #   use_write_multiple: true
    #   bitmask: 8192

##############################
# Holding Register Numbers   #
##############################

number:
  # Number Holding registers - ordered by register id
  - platform: modbus_controller
    name: "Inverter Max Active Power output percent"
    register_type: holding
    mode: box
    address: 0x0003
    value_type: U_WORD
    min_value: 1
    max_value: 100
    step: 1
    use_write_multiple: true
  - platform: modbus_controller
    name: "Inverter Export Limit Power percent"
    register_type: holding
    mode: box
    address: 0x0123
    value_type: U_WORD
    min_value: 0
    max_value: 100
    step: 1
    multiply: 10
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery LoadFirst Discharge stop SOC"
    register_type: holding
    mode: box
    address: 0x0608
    value_type: U_WORD
    min_value: 10
    max_value: 100
    step: 1
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery GridFirst Discharge Power"
    register_type: holding
    mode: box
    address: 0x1070
    value_type: U_WORD
    min_value: 0
    max_value: 100
    step: 1
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery GridFirst Discharge stop SOC"
    register_type: holding
    mode: box
    address: 0x1071
    value_type: U_WORD
    min_value: 10
    max_value: 100
    step: 1
    use_write_multiple: true
  
    # Grid First - Timeslot 1
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 1 start Hour"
    register_type: holding
    mode: box
    address: 0x1080
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = gridfirst_timer1_start_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 1 start Minute"
    register_type: holding
    mode: box
    address: 0x1080
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = gridfirst_timer1_start_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 1 stop Hour"
    register_type: holding
    mode: box
    address: 0x1081
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = gridfirst_timer1_stop_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 1 stop Minute"
    register_type: holding
    mode: box
    address: 0x1081
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = gridfirst_timer1_stop_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;

    # Grid First - Timeslot 2
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 2 start Hour"
    register_type: holding
    mode: box
    address: 0x1083
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = gridfirst_timer2_start_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 2 start Minute"
    register_type: holding
    mode: box
    address: 0x1083
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = gridfirst_timer2_start_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 2 stop Hour"
    register_type: holding
    mode: box
    address: 0x1084
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = gridfirst_timer2_stop_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 2 stop Minute"
    register_type: holding
    mode: box
    address: 0x1084
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = gridfirst_timer2_stop_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;

    # Grid First - Timeslot 3
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 3 start Hour"
    register_type: holding
    mode: box
    address: 0x1086
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = gridfirst_timer3_start_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 3 start Minute"
    register_type: holding
    mode: box
    address: 0x1086
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = gridfirst_timer3_start_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 3 stop Hour"
    register_type: holding
    mode: box
    address: 0x1087
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = gridfirst_timer3_stop_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery GridFirst Timeslot 3 stop Minute"
    register_type: holding
    mode: box
    address: 0x1087
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = gridfirst_timer3_stop_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;

  - platform: modbus_controller
    name: "Battery BatteryFirst Charge Power"
    register_type: holding
    mode: box
    address: 0x1090
    value_type: U_WORD
    min_value: 1
    max_value: 100
    step: 1
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery BatteryFirst Charge stop SOC"
    register_type: holding
    mode: box
    address: 1091
    value_type: U_WORD
    min_value: 10
    max_value: 100
    step: 1
    use_write_multiple: true

    # Battery First - Timeslot 1
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 1 start Hour"
    register_type: holding
    mode: box
    address: 0x1100
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = batfirst_timer1_start_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 1 start Minute"
    register_type: holding
    mode: box
    address: 0x1100
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = batfirst_timer1_start_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 1 stop Hour"
    register_type: holding
    mode: box
    address: 0x1101
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = batfirst_timer1_stop_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 1 stop Minute"
    register_type: holding
    mode: box
    address: 0x1101
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = batfirst_timer1_stop_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;

    # Battery First - Timeslot 2
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 2 start Hour"
    register_type: holding
    mode: box
    address: 0x1103
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = batfirst_timer2_start_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 2 start Minute"
    register_type: holding
    mode: box
    address: 0x1103
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = batfirst_timer2_start_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 2 stop Hour"
    register_type: holding
    mode: box
    address: 0x1104
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = batfirst_timer2_stop_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 2 stop Minute"
    register_type: holding
    mode: box
    address: 0x1104
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = batfirst_timer2_stop_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;

    # Battery First - Timeslot 3
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 3 start Hour"
    register_type: holding
    mode: box
    address: 0x1106
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    use_write_multiple: true
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = batfirst_timer3_start_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 3 start Minute"
    register_type: holding
    mode: box
    address: 0x1106
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = batfirst_timer3_start_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 3 stop Hour"
    register_type: holding
    mode: box
    address: 0x1107
    value_type: U_WORD
    min_value: 0
    max_value: 23
    step: 1
    lambda: !lambda |-
      return float(int(x) >> 8);
    write_lambda: !lambda |-
      float hour = x;
      float minute = batfirst_timer3_stop_minute->get_state();
      ESP_LOGD("main","hour set to : %f", hour);
      ESP_LOGD("main","minute set to : %f", minute);
      float returnval = float((int(hour) << 8 ) + minute );
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
    use_write_multiple: true
  - platform: modbus_controller
    name: "Battery BatteryFirst Timeslot 3 stop Minute"
    register_type: holding
    mode: box
    address: 0x1107
    value_type: U_WORD
    min_value: 0
    max_value: 59
    step: 1
    lambda: !lambda |-
      return float(int(x) & 255);
    write_lambda: !lambda |-
      int hour = batfirst_timer3_stop_hour->get_state();
      int minute = x;
      ESP_LOGD("main","hour set to : %d", hour);
      ESP_LOGD("main","minute set to : %d", minute);
      float returnval = (hour << 8 ) + minute;
      ESP_LOGD("main","returnval: %f", returnval);
      return returnval;
    use_write_multiple: true

  #
  # Experimental numbers for testing
  #
  # - platform: modbus_controller
  #   name: "Battery Float Charge current limit"
  #   register_type: holding
  #   mode: box
  #   address: 0x1000
  #   value_type: U_WORD
  #   min_value: 1000
  #   max_value: 6000
  #   step: 1
  #   use_write_multiple: true
  # - platform: modbus_controller
  #   name: "Battery Charge stop Voltage"
  #   register_type: holding
  #   mode: box
  #   address: 0x1005
  #   value_type: U_WORD
  #   min_value: 480
  #   max_value: 580
  #   step: 5
  # - platform: modbus_controller
  #   name: "Inverter upper temp limit for charge "
  #   register_type: holding
  #   mode: box
  #   address: 0x1012
  #   value_type: U_WORD
  #   min_value: 20
  #   max_value: 1000
  #   step: 1

##################################
# Input (READ) Register Sensors  #
##################################

sensor:
      # Timer read sensor - internal use in esphome for lamdba
      # Grid First - Timeslot 1 read
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 1 start Hour-READ"
      id: gridfirst_timer1_start_hour
      internal: true
      register_type: holding
      address: 0x1080
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 1 start Minute-READ"
      id: gridfirst_timer1_start_minute
      internal: true
      register_type: holding
      address: 0x1080
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 1 stop Hour-READ"
      id: gridfirst_timer1_stop_hour
      internal: true
      register_type: holding
      address: 0x1081
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 1 stop Minute-READ"
      id: gridfirst_timer1_stop_minute
      internal: true
      register_type: holding
      address: 0x1081
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
      # Grid First - Timeslot 2 read
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 2 start Hour-READ"
      id: gridfirst_timer2_start_hour
      internal: true
      register_type: holding
      address: 0x1084
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 2 start Minute-READ"
      id: gridfirst_timer2_start_minute
      internal: true
      register_type: holding
      address: 0x1084
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 2 stop Hour-READ"
      id: gridfirst_timer2_stop_hour
      internal: true
      register_type: holding
      address: 0x1085
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 2 stop Minute-READ"
      id: gridfirst_timer2_stop_minute
      internal: true
      register_type: holding
      address: 0x1085
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
      # Grid First - Timeslot 3 read
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 3 start Hour-READ"
      id: gridfirst_timer3_start_hour
      internal: true
      register_type: holding
      address: 0x1087
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 3 start Minute-READ"
      id: gridfirst_timer3_start_minute
      internal: true
      register_type: holding
      address: 0x1087
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 3 stop Hour-READ"
      id: gridfirst_timer3_stop_hour
      internal: true
      register_type: holding
      address: 0x1088
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery GridFirst Timeslot 3 stop Minute-READ"
      id: gridfirst_timer3_stop_minute
      internal: true
      register_type: holding
      address: 0x1088
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
      # Battery First - Timeslot 1 read
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 1 start Hour-READ"
      id: batfirst_timer1_start_hour
      internal: true
      register_type: holding
      address: 0x1100
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 1 start Minute-READ"
      id: batfirst_timer1_start_minute
      internal: true
      register_type: holding
      address: 0x1100
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 1 stop Hour-READ"
      id: batfirst_timer1_stop_hour
      internal: true
      register_type: holding
      address: 0x1101
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 1 stop Minute-READ"
      id: batfirst_timer1_stop_minute
      internal: true
      register_type: holding
      address: 0x1101
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
      # Battery First - Timeslot 2 read
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 2 start Hour-READ"
      id: batfirst_timer2_start_hour
      internal: true
      register_type: holding
      address: 0x1103
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 2 start Minute-READ"
      id: batfirst_timer2_start_minute
      internal: true
      register_type: holding
      address: 0x1103
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 2 stop Hour-READ"
      id: batfirst_timer2_stop_hour
      internal: true
      register_type: holding
      address: 0x1104
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 2 stop Minute-READ"
      id: batfirst_timer2_stop_minute
      internal: true
      register_type: holding
      address: 0x1104
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
      # Battery First - Timeslot 3 read
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 3 start Hour-READ"
      id: batfirst_timer3_start_hour
      internal: true
      register_type: holding
      address: 0x1106
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 3 start Minute-READ"
      id: batfirst_timer3_start_minute
      internal: true
      register_type: holding
      address: 0x1106
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 3 stop Hour-READ"
      id: batfirst_timer3_stop_hour
      internal: true
      register_type: holding
      address: 0x1107
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) >> 8);
    - platform: modbus_controller
      name: "Battery BatteryFirst Timeslot 3 stop Minute-READ"
      id: batfirst_timer3_stop_minute
      internal: true
      register_type: holding
      address: 0x1107
      value_type: U_WORD
      lambda: !lambda |-
        return float(int(x) & 255);
    # Regular Sensors - ordered by register id
    - platform: modbus_controller
      name: "Solar DC Input Power"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0001
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Solar PV1 DC Voltage"
      unit_of_measurement: "V"
      device_class: voltage
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x0003
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Solar PV1 DC Current"
      unit_of_measurement: "A"
      device_class: current
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x0004
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Solar PV1 DC Power"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0005
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Solar PV2 DC Voltage"
      unit_of_measurement: "V"
      device_class: voltage
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x0007
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Solar PV2 DC Current"
      unit_of_measurement: "A"
      device_class: current
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x0008
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Solar PV2 DC Power"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0009
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Inverter Output Power"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0035
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Inverter Output Power VA"
      unit_of_measurement: "VA"
      device_class: apparent_power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0040
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Inverter Energy today"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total_increasing
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0053
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Inverter Energy total"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0055
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Solar PV1 Energy today"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total_increasing
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0059
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Solar PV2 Energy today"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0063
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Solar Solar Energy total"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x0091
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Inverter Temperature"
      unit_of_measurement: "C"
      device_class: temperature
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x0093
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Inverter Temperature IPM"
      unit_of_measurement: "C"
      device_class: temperature
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x0094
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Inverter Temperature Boost"
      unit_of_measurement: "C"
      device_class: temperature
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x0095
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Battery Discharging Power"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1009
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Battery Charging Power"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1011
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Battery Voltage"
      unit_of_measurement: "V"
      device_class: voltage
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x1013
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Battery SOC"
      unit_of_measurement: "%"
      device_class: battery
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x1014
    - platform: modbus_controller
      name: "Meter AC Grid Import Power"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1021
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Meter AC Grid Export Power"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1029
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Inverter AC Load Power"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1037
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Meter Imported Energy today"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total_increasing
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1044
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Meter Imported Energy total"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1046
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Meter Exported Energy today"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total_increasing
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1048
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Meter Exported Energy total"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1050
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Battery Discharged Energy today"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total_increasing
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1052
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Battery Discharged Energy total"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1054
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Battery Charged Energy today"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total_increasing
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1056
      filters:
        - multiply: 0.1
    - platform: modbus_controller
      name: "Battery Charged Energy total"
      unit_of_measurement: "kWh"
      device_class: energy
      state_class: total
      accuracy_decimals: 1
      register_type: read
      value_type: U_DWORD
      address: 0x1058
      filters:
        - multiply: 0.1
    # Depends on BMS, if using non growatt battery you may get nothing
    - platform: modbus_controller
      name: "Battery BMS Current"
      unit_of_measurement: "A"
      device_class: current
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 0x1088
      filters:
        - multiply: 0.001
    # Depends on BMS, if using non growatt battery you may get nothing
    - platform: modbus_controller
      name: "Battery BMS Temperature"
      unit_of_measurement: "C"
      device_class: temperature
      state_class: measurement
      accuracy_decimals: 1
      register_type: read
      value_type: U_WORD
      address: 1089
      #filters:
      #  - multiply: 0.001
    # Depends on BMS, if using non growatt battery you may get nothing
    # On my BSLBatt it looks to be the summary cell voltage for battery1, not cell1.
    # - platform: modbus_controller
    #   name: "Battery BMS Cell1 Voltage"
    #   unit_of_measurement: "V"
    #   device_class: voltage
    #   state_class: measurement
    #   accuracy_decimals: 1
    #   register_type: read
    #   value_type: U_WORD
    #   address: 0x1108
    #   filters:
    #     - multiply: 0.001
    # Depends on BMS, if using non growatt battery you may get nothing
    # On my BSLBatt it looks to be the summary cell voltage for battery2, not cell2.
    # - platform: modbus_controller
    #   name: "Battery BMS Cell2 Voltage"
    #   unit_of_measurement: "V"
    #   device_class: voltage
    #   state_class: measurement
    #   accuracy_decimals: 1
    #   register_type: read
    #   value_type: U_WORD
    #   address: 0x1109
    #   filters:
    #     - multiply: 0.001
    # add for more batteries/cells - up to 16 (id: 1123)
    #
    # Experimental registers read for test
    #
    # - platform: modbus_controller
    #   name: "Inverter ExportLimitEN"
    #   accuracy_decimals: 1
    #   register_type: holding
    #   value_type: U_WORD
    #   address: 0x0122
    # - platform: modbus_controller
    #   name: "Inverter EESysInfo"
    #   accuracy_decimals: 1
    #   register_type: holding
    #   value_type: U_WORD
    #   address: 0x1008
    # - platform: modbus_controller
    #   name: "Inverter Battery Temperature"
    #   unit_of_measurement: "C"
    #   device_class: temperature
    #   state_class: measurement
    #   accuracy_decimals: 1
    #   register_type: read
    #   value_type: U_WORD
    #   address: 0x1040

#######################################
# Input (READ) Register Text Sensors  #
#######################################

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "Growatt IP Address"
    ssid:
      name: "Growatt WiFi SSID"
    bssid:
      name: "Growatt WiFi BSSID"
  - platform: version
    name: "ESPHome Version"
    hide_timestamp: true
  - platform: modbus_controller
    register_type: read
    address: 0x0000
    raw_encode: HEXBYTES
    name: Inverter Status
    # Status 5 is not documented, but my SPH sends this when in Normal condition
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      ESP_LOGD("main","status value : %d", value);
      switch (value) {
        case 0: return std::string("waiting");
        case 1: return std::string("normal");
        case 3: return std::string("fault");
        case 5: return std::string("normal");
        default: return std::string("unknown");
      }
      return x;
  - platform: modbus_controller
    register_type: read
    address: 0x0118
    raw_encode: HEXBYTES
    name: Inverter Operating Mode
    lambda: |-
      uint16_t value = modbus_controller::word_from_hex_str(x, 0);
      ESP_LOGD("main","opermode value : %d", value);
      switch (value) {
        case 0: return std::string("Load first");
        case 1: return std::string("Battery First");
        case 2: return std::string("Grid First");
        default: return std::string("unknown");
      }
      return x;


###################################
# Buttons for Restart / Shutdown  #
###################################


button:
  - platform: restart
    name: "Growatt ESP32 Restart"
#  - platform: template
#    name: "Inverter - remote shutdown (WARNING - No remote start)"
#    on_press:
#      then:
#        - lambda: |-
#            modbus_controller::ModbusController *controller = id(growatt_modbus_controller);
#            modbus_controller::ModbusCommandItem shutdowninv = modbus_controller::ModbusCommandItem::create_write_single_command(controller, 0, 0);
#            controller->queue_command(shutdowninv);

